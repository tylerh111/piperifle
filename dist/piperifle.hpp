// piperifle 0.0
// https://github.com/tylerh111/piperifle
//
// SPDX-FileCopyrightText: 2024 - present Tyler Hughes
// SPDX-License-Identifier: MIT
// autogenerated - do not modify

#ifndef PIPERIFLE_HPP_
#define PIPERIFLE_HPP_

#define PIPERIFLE_VERSION "0.0"
#define PIPERIFLE_VERSION_MAJOR "0"
#define PIPERIFLE_VERSION_MINOR "0"
/* #undef PIPERIFLE_VERSION_PATCH */
/* #undef PIPERIFLE_VERSION_TAG */

// #include <piperifle/pipe.hpp>
#ifndef PIPERIFLE_PIPE_HPP_
#define PIPERIFLE_PIPE_HPP_

#include <tuple>
#include <utility>


namespace piperifle {

struct pipeline
{
    template <typename... Args>
    constexpr auto execute(Args... args) -> decltype(auto)
    {
        return std::make_tuple(std::forward<Args>(args)...);
    }
};

template <typename... Args>
constexpr auto execute(auto&& pipe, Args... args) -> decltype(auto)
{
    return pipe.execute(std::forward<Args>(args)...);
}

template <typename Root, typename Pipe>
constexpr auto connect(Root&& root, Pipe&& pipe) -> decltype(auto)
{
    return pipe.connect(std::move(root));
}

template <typename Root, typename Pipe>
inline constexpr auto operator|(Root&& root, Pipe&& pipe) -> decltype(auto)
{
    return connect(std::forward<Root>(root), std::forward<Pipe>(pipe));
}

}  // namespace piperifle

#endif  // PIPERIFLE_PIPE_THEN_HPP_
// #include <piperifle/pipe_just.hpp>
#ifndef PIPERIFLE_PIPE_JUST_HPP_
#define PIPERIFLE_PIPE_JUST_HPP_

namespace piperifle {
namespace details {

template <typename Root, typename Value>
struct pipe_just_connected_
{
    using root_t = Root;
    using value_t = Value;
    root_t root;
    value_t value;

    template <typename... Args>
    constexpr auto execute(Args&&... args) -> decltype(auto)
    {
        auto taskargs = root.execute(std::forward<Args>(args)...);
        return std::tuple_cat(taskargs, std::make_tuple(value));
    }
};

template <typename Value>
struct pipe_just_
{
    template <typename Root>
    using root_t = pipe_just_connected_<Root, Value>;
    using value_t = Value;
    value_t value;

    template <typename Root>
    constexpr auto connect(Root&& root) {
        return pipe_just_connected_<Root, Value>{std::move(root), std::move(value)};
    }
};

}  // namespace details

template <typename Root, typename Value>
constexpr auto just(Root&& root, Value&& value) -> decltype(auto)
{
    return details::pipe_just_<Value>{std::move(value)}.connect(std::move(root));
}

template <typename Value>
constexpr auto just(Value&& value) -> decltype(auto)
{
    return details::pipe_just_<Value>{std::move(value)};
}

}  // namespace piperifle

#endif  // PIPERIFLE_PIPE_JUST_HPP_
// #include <piperifle/pipe_then.hpp>
#ifndef PIPERIFLE_PIPE_THEN_HPP_
#define PIPERIFLE_PIPE_THEN_HPP_

#include <functional>
#include <tuple>
#include <type_traits>
#include <utility>

namespace piperifle {
namespace details {

template <typename Root, typename Task>
struct pipe_then_connected_
{
    using root_t = Root;
    using task_t = Task;
    root_t root;
    task_t task;

    template <typename... Args>
    constexpr auto execute(Args&&... args) -> decltype(auto)
    {
        auto taskargs = root.execute(std::forward<Args>(args)...);
        if constexpr (std::is_void_v<decltype(std::apply(task, taskargs))>) {
            std::apply(task, taskargs);
            return;
        } else if constexpr (
            auto results = std::apply(task, taskargs);
            requires {std::tuple_size<decltype(results)>::value;}) {
            return results;
        } else {
            return std::make_tuple(results);
        }
    }

};

template <typename Task>
struct pipe_then_
{
    template <typename Root>
    using root_t = pipe_then_connected_<Root, Task>;
    using task_t = Task;
    task_t task;

    template <typename Root>
    constexpr auto connect(Root&& root) {
        return pipe_then_connected_<Root, Task>{std::move(root), std::move(task)};
    }
};

}  // namspace details

template <typename Root, typename Task>
constexpr auto then(Root&& root, Task&& task) -> decltype(auto)
{
    return details::pipe_then_<Task>{std::move(task)}.connect(std::move(root));
}

template <typename Task>
constexpr auto then(Task&& task) -> decltype(auto)
{
    return details::pipe_then_<Task>{std::move(task)};
}

}  // namespace piperifle

#endif  // PIPERIFLE_PIPE_THEN_HPP_

#endif  // PIPERIFLE_HPP_
